Go for Statistical Programming
NY Open Statistical Programming Meetup: Knewton HQ
19 Aug 2013

Aditya Mukerjee

http://www.adityamukerjee.net
@chimeracoder

* 
.image 88x31.png

* Personal Background

- Studied computer science and statistics at Columbia
- Worked on the server team at foursquare (Explore recommendation engine)
- Previously on the OkCupid data team (conducted research for OkTrends reports)
- Most recently, Hacker-in-Residence at Quotidian Ventures
- hackNY fellow 2011


* OkCupid Data Workflow (circa 2009)
- 80% munging (Python), 20% statistical analysis (R)


* Python in 2009
- In 2009, Python was useable for data science, but not as convenient as today
- Tools like Pandas either didn't exist yet or were not stable/widely adopted
- RPy existed (since 2002)
- Numpy existed (since 2005, previously "Numeric")
- Scipy existed, though with far fewer components and features
- All the munging tools were in place, but numerical tools were lagging somewhat

* Go in 2013

Numerical tools exist, but are still WIPs

- [[https://github.com/sbinet/go-python][go-python]] provides CPython bindings
- [[https://github.com/skelterjohn/go.matrix][go-matrix]] provides some vector/matrix operations
- No clear equivalent to Pandas yet



* Advantages of Go

- Very fast (runtime)
- Very fast (compilation)
- Native concurrency 
- Easy parallelization (R is single threaded, Python has GIL)
- Portable (cross-compilation)
- Can call other languages from within Go
- Type system: safety of static typing, with the flexibility of dynamic (via interfaces)


* Disadvantages of Go

- Relatively new language (but not that new)!
- "main" function must be written in Go


* Speed

- Go tends to be *>10x* faster than Python (and *>50x* faster than R)
- Go compiles as fast as the Python interpreter takes to start up


* Type system

- Go is *statically*typed* 
- Go's *type*inference* makes static typing painless
.code typing_example.go
- Go's *interfaces* provide some of the benefits of dynamic typing
- Refactoring and debugging are easier because the compiler is strict

* Concurrency in Go

* Go's Concurrency Model:
- "Do not communicate by sharing memory; instead, share memory by communicating.""
- Make writing concurrent, asynchronous code as easy as writing synchronous code


* Concurrency in Go: Goroutines
- Goroutines are *not* threads
- Goroutines are *not* coroutines
- Goroutines are *not* processes


* So what is a goroutine?
[[http://golang.org/doc/effective_go.html#goroutines][From the docs]]
- A goroutine is "a function executing concurrently with other goroutines in the same address space"
- Goroutines are *light*
- Goroutines are *multiplexed* onto multiple OS threads
- Goroutines are similar to the *&* operator in bash/sh




* Synchronicity by Example
.play synchronous_greet.go


* Goroutines by Example
.play async_greet.go

Yes, it really is just that easy.


* Concurrency in Go: Channels
- Channels provide a convenient way to share information between goroutines
- Channels serve as a "synchronization point" between otherwise independent, concurrent goroutines


* Channels by Example:
.play channel_example.go

* Let's take a closer look at that:
.play channel_example_annotated.go


* Go makes concurrency easy
- Goroutines are easy to reason about
- Channels make sharing information between goroutines easy
- Go includes [[http://golang.org/doc/articles/race_detector.html][a built-in race detector]]


* Data processing in Go

* Go Standard Library
Some tools included for free in the [[http://golang.org/pkg/][standard library]]:

- [[http://golang.org/pkg/image/][Image processing]]: GIF/JPEG/PNG decoder & encoder, and [[http://golang.org/pkg/image/draw/][image composition]]
- Web scraping: [[http://golang.org/pkg/encoding/xml/][xml]] parser
- Email: [[http://golang.org/pkg/net/mail/][parse]] and [[http://golang.org/pkg/net/smtp/][send]] emails
- Numerical tools: Arithmetic on [[http://golang.org/pkg/math/big/][large numbers]] and [[http://golang.org/pkg/math/cmplx/][complex/imaginary]] numbers

* Data scraping in Go

* Example: Rate-Limiting & Scraping

- (For the full project, see [[github.com/ChimeraCoder/goangel][goangel]] on Github)
.code rate_limit_example.go


- This lets us decouple the asynchronous scraping from the (synchronous) rate-limiting


* Channels for parallel computation

- If a computation can be split into independent components, it can be parallelized
- Channels can be used to signal completion of a portion of the work
- Channels can be used to select the fastest algorithm


* Selecting Channels
- "select" will read from the first channel that sends a value
.code select_example.go /START OMIT/,/END OMIT/

- This can also be used to initiate timeouts
.code select_timeout_example.go /START OMIT/,/END OMIT/

* Example: Data Collection with Background Computation

.image 2013-08-18-220614_1366x768_scrot.png


* Other useful munging tools

[[github.com/ChimeraCoder/gojson][go-json]] - automatically generate static struct definitions for JSON unmarshalling
[[labix.org/mgo][mgo]] - a MongoDB client library for Go
[[github.com/garyburd/redigo/redis][redigo]] - A Redis client library in Go


* Conclusion

- Go is *already* an excellent tool for data processing, scraping, munging, and scripting
- Go is *becoming* an excellent tool for numerical work and scientific computation
